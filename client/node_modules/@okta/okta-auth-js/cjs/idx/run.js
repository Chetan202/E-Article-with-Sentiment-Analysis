"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

exports.run = run;

var _interact = require("./interact");

var _introspect = require("./introspect");

var _remediate = require("./remediate");

var remediators = _interopRequireWildcard(require("./remediators"));

var _types = require("../types");

/* eslint-disable max-statements, complexity */
function getEnabledFeatures(idxResponse) {
  const res = [];
  const {
    actions,
    neededToProceed
  } = idxResponse;

  if (actions['currentAuthenticator-recover']) {
    res.push(_types.IdxFeature.PASSWORD_RECOVERY);
  }

  if (neededToProceed.some(({
    name
  }) => name === 'select-enroll-profile')) {
    res.push(_types.IdxFeature.REGISTRATION);
  }

  if (neededToProceed.some(({
    name
  }) => name === 'redirect-idp')) {
    res.push(_types.IdxFeature.SOCIAL_IDP);
  }

  return res;
}

function getAvailableSteps(remediations) {
  const res = [];
  const remediatorMap = Object.values(remediators).reduce((map, remediatorClass) => {
    // Only add concrete subclasses to the map
    if (remediatorClass.remediationName) {
      map[remediatorClass.remediationName] = remediatorClass;
    }

    return map;
  }, {});

  for (let remediation of remediations) {
    const T = remediatorMap[remediation.name];

    if (T) {
      const remediator = new T(remediation);
      res.push(remediator.getNextStep());
    }
  }

  return res;
}

async function run(authClient, options) {
  let tokens;
  let nextStep;
  let messages;
  let error;
  let meta;
  let enabledFeatures;
  let availableSteps;
  let status = _types.IdxStatus.PENDING;
  let shouldClearTransaction = false;

  try {
    // Start/resume the flow
    const {
      interactionHandle,
      meta: metaFromResp
    } = await (0, _interact.interact)(authClient, options); // Introspect to get idx response

    const idxResponse = await (0, _introspect.introspect)(authClient, {
      interactionHandle
    });

    if (!options.flow && !options.actions) {
      // handle start transaction
      meta = metaFromResp;
      enabledFeatures = getEnabledFeatures(idxResponse);
      availableSteps = getAvailableSteps(idxResponse.neededToProceed);
    } else {
      const values = { ...options,
        stateHandle: idxResponse.rawIdxState.stateHandle
      }; // Can we handle the remediations?

      const {
        idxResponse: idxResponseFromResp,
        nextStep: nextStepFromResp,
        terminal,
        canceled,
        messages: messagesFromResp
      } = await (0, _remediate.remediate)(idxResponse, values, options); // Track fields from remediation response

      nextStep = nextStepFromResp;
      messages = messagesFromResp; // Save intermediate idx response in storage to reduce introspect call

      if (nextStep && idxResponseFromResp) {
        authClient.transactionManager.saveIdxResponse(idxResponseFromResp.rawIdxState);
      }

      if (terminal) {
        status = _types.IdxStatus.TERMINAL;
        shouldClearTransaction = true;
      }

      if (canceled) {
        status = _types.IdxStatus.CANCELED;
        shouldClearTransaction = true;
      } else if (idxResponseFromResp !== null && idxResponseFromResp !== void 0 && idxResponseFromResp.interactionCode) {
        const {
          clientId,
          codeVerifier,
          ignoreSignature,
          redirectUri,
          urls,
          scopes
        } = metaFromResp;
        tokens = await authClient.token.exchangeCodeForTokens({
          interactionCode: idxResponseFromResp.interactionCode,
          clientId,
          codeVerifier,
          ignoreSignature,
          redirectUri,
          scopes
        }, urls);
        status = _types.IdxStatus.SUCCESS;
        shouldClearTransaction = true;
      }
    }
  } catch (err) {
    error = err;
    status = _types.IdxStatus.FAILURE;
    shouldClearTransaction = true;
  }

  if (shouldClearTransaction) {
    authClient.transactionManager.clear();
  }

  return {
    status,
    ...(meta && {
      meta
    }),
    ...(enabledFeatures && {
      enabledFeatures
    }),
    ...(availableSteps && {
      availableSteps
    }),
    ...(tokens && {
      tokens: tokens.tokens
    }),
    ...(nextStep && {
      nextStep
    }),
    ...(messages && {
      messages
    }),
    ...(error && {
      error
    })
  };
}
//# sourceMappingURL=run.js.map